# 지민

## 별찍기

가운데 별이 위치하고 카운트가 증가할 때마다 양쪽에 별이 하나씩 늘어나는 문제이다.

입력된 숫자만큼 반복을 해야했기에 `for문`을 사용하였다.

`String`타입은 `+`연산자를 사용하면 문자열을 연결 시킬 수 있다는 점과 `*`연산자를 사용해 문자의 개수를 곱할 수 있다는 점을 이용했다.

공백이 점점 줄어들기 때문에 `range`의 `step`을 줄어들게 하는 방법을 사용함

## 달팽이는 올라가고 싶다

처음에는 `while`문을 사용하여 구현하였다

남짜가 오래 안걸리는 날에는 문제가 없었지만 입력3 처럼 오래 걸리는 날에는 시간 초과가 발생하였다.

달팽이가 목표 높이까지 도달하기 전날까지는 다음을 반복한다는 사실을 알게됨

- 낮에는 올라감
- 밤에는 내려감

그래서 `하루에 올라가는 높이`(마지막날 제외)를 `전날 목표 높이`에 나누면 훨씬 빠르게 걸리는 일 수 를 알 수 있었다.

여기서 바로 `day = yesterday_height // one_day_height + 1`을 사용했지만 실패가 나왔다.

고민을 해본 결과 전날 목표 높이까지 걸리는 일수를 계산할 때 나머지가 있다면 올림을 해줘야 한다는 사실을 알게됨

`math`라이브러리를 사용하는 방법을 찾았지만 조건문으로 올림을 하는 방식을 사용하였다.

## 최대공약수와 최소 공배수

#### 최대공약수를 구하는 방법

- 2부터 시작하여 두 수를 계속 나눔
- 더 이상 나눠지지 않으면 이때까지 나눴던 수를 곱하면 최소 공배수가 됨
- 리스트에 넣어서 그 수들을 곱했다.

#### 최소공배수를 구하는 방법

- 양쪽 수에서 작은 수에 2부터 곱해봄
- 계속 곱하면서 두 수가 같아질때까지 곱함

두 수로 최대공약수와 최소공배수를 같이 찾아야하기 때문에 입력받은 두 수를 다른 변수에 할당하여 문제를 품

변수의 이름을 비슷하게 사용하였는데 헷갈려서 이름을 다시 바꿈

## 평균

과목 별 원래 점수를 리스트로 할당하고 `max`함수를 사용하여 최고점을 구했다

리스트 컴프리헨션을 사용하여 새로 조작한 점수 리스트를 만들었다.

새로운 점수 리스트로 평균을 새로 구하였다.

## 색종이

종이가 놓여질 수 있는 평면은 최대 가로 101칸 세로 101칸이기 때문에 먼저 평면을 2차원 배열로 만들었다. -> 최대 1001칸이었다.

주어진 색종이의 순서에 따라 입력받은 좌표값에 높이와 너비만큼 반복하여 색종이를 칠해주었다.

평면을 모두 순회하면서 각 색종이의 번호를 `count`하여 색종이들의 면적을 구했다.

> 42점이 나왔다.

- 입력조건을 잘못봤다
- 1001을 넣으니 성공하였다

## 딱지놀이

서로가 낸 딱지의 모양의 우선순위에 따라 승패를 출력하는 문제

딱지의 모양별로 개수를 카운팅해 비교한다.

`index`로 추가해주기 위해 `index:0`을 더미로 추가해서 만든다.

어린이가 낸 딱지의 모양을 모양 개수 리스트에 카운팅 해준다.

모양 개수 리스트를 순회하며 두 어린이의 승패를 결정한다.

실수

- 두 어린이의 입력값의 첫번째는 카드의 개수였는데 문제를 잘 못 읽고 카드 카운팅에 추가하였다.
- 승패를 결정하는 반복문의 범위가 4->3->2->1로 가야하는데 잘못해서 시간이 좀 걸렸다.

## 자리배정

좌석을 시계방향으로 배치에 원하는 좌석의 x, y 좌표값을 알아내는 문제

처음에는 4방향을 각각 `for문`을 돌려 좌석을 배치하려 했지만 `range`의 범위가 너무 복잡해졌다.

그래서 각 방향을 변수로 만들고 각 방향에 따라 인덱스를 변화시켜주어 좌석을 배치했다.

하지만 이 방법도 복잡도가 높고 범위의 계산이 어렵다는 단점이 있다.

추후에 다른 방법을 생각해보는 것이 좋을듯하다.

## 1221 GNS

숫자를 문자열로 표현한 리스트를 정렬하여 문자열로 다시 출력하는 문제

먼저 문자열의 숫자 순서대로 담은 리스트를 만든다.

모든 문자열을 순회하면서 각 문자열을 문자열 숫자 리스트에서 찾아 리스트로 다시 만든다 -> 정수형 리스트

만들어진 리스트는 정수형이라 정렬이 가능하다. -> 정렬

정렬된 정수 리스트를 다시 순회하면서 문자열로 바꿔준다.

## 3143 가장 빠른 문자열 타이핑

문자열 A와 B가 있다. B가 A에 포함되어있다면 타이핑 횟수를 줄일 수 있다. 최소 타이핑 횟수를 구하는 문제

완전탐색으로 A문자열에 B가 몇개 있는지 개수를 구한다.

구한 개수를 적절히 빼주어 타이핑 횟수를 구한다.

# 프로그래머스

## K번째수

프로그래머스의 수는 1부터 시작하여 인덱스를 잘 봐야한다.

카운팅 정렬을 구현하여 정렬을 하였다.

배열을 슬라이싱하여 부분배열을 만들어 정렬한 뒤 K번째 수를 찾았다.

## 최소사각형 - 완전탐색

명함의 크기가 주어질 때 모든 명함을 넣을 수 있는 지갑의 최소크기를 구하는 문제

명함을 회전시켜서 넣을 수 있다는 점이 재밌다.

따라서 두 변을 입력 받을 때 큰 값을 가로, 작은 값을 세로로 넣어준다.

가로와 세로의 최댓값을 구하면 모든 명함이 들어갈 수 있는 지갑의 최소크기를 구할 수 있다.

## 체육복

체육복을 도난 당하고, 빌려주고, 체육복을 가진 최대 학생수를 구하여라.

학생들의 체육복의 개수를 세어주는 리스트 만든다.

앞에서부터 뒤, 앞 친구들이 여분의 체육복을 가지고 있는지 확인하고 빌린다.

체육복을 가진 최대 학생수를 구한다.

## 1215 회문1

글자판에서 회문의 개수가 몇개인지 구하는 문제

회문 문제처럼 입력값 K만큼 리스트로 받아 리스트를 뒤집어 일치하는지 검사하며 개수를 구한다.

## 1989 초심자의 회문 검사

입력받은 문자열이 뒤집어도 똑같은지 확인하는 문제

입력받은 문자열을 슬라이싱으로 뒤집어 비교한 결과를 구한다.

## 4864 회문

가로열과 세로열에 길이가 M만큼인 문자열이 뒤집어도 같은 문자열을 찾는 문제

길이가 M인 문자열을 만들고 그 문자열을 슬라이싱을 통해 반대로 뒤집어주었다.

## 4865 글자수

str1의 단어들이 str2에 몇개 들어있는지, 최대 개수를 구하는 문제

str1의 각 단어들을 딕셔너리로 만들어서 글자와 개수를 구했다

다시 딕셔너리를 순회하면서 최대 개수를 구했다.

## 1974 스도쿠 검증

주어진 스도쿠가 맞는지 아닌지 확인하는 문제

스도쿠의 숫자들을 행 방향, 열 방향, 3X3 부분 모두 하나씩 검사해본다.

전부다 탐색하는 방법을 사용하여 인덱스 범위를 지정하는 것이 중요하다

다른 방법을 사용할 수 있을거 같다.

## 2005 파스칼의 삼각형

입력받은 숫자크기의 파스칼의 삼각형을 출력하는 문제

위에 줄의 앞에 숫자와 위에 숫자를 더한 규칙이 있다.

현재 줄의 맨 앞 숫자와 맨 뒤 숫자가 1로 고정되고 그 후에는 규칙대로 만들면 된다.

현재 줄을 다 출력하면 현재줄을 위에 줄로 갱신해준다.

## 반복문자 지우기

주어진 문자열에서 중복되는 문자열이 있다면 지우는 문제

스택을 사용하여 구하였다.

스택의 0번째는 무조건 `push` 그 외 top이 중복이라면 `pop`, 아니라면 `push`

마지막으로 스택의 길이를 구하면 된다.

## 4866 괄호검사

`{}`와 `()`가 잘 사용되었는지 확인하는 문제

스택을 사용하여 괄호를 확인한다.

`pop`을 할 때 `top`의 괄호를 보고 조건을 결정한다.

## 1234 비밀번호

입력된 비밀번호에서 중복을 제거해 만든 비밀번호를 구하는 문제

`Stack클래스`를 만들어 푼다.

`get`메서드를 통해서 스택의 제일 위의 요소와 현재 숫자를 비교하여 중복여부를 파악한다.

## 4871 그래프 경로

노드를 간선으로 연결한 그래프의 정보를 준다. 출발노드에서 도착노드에 도달할 수 있는지 구하는 문제

`Stack`을 이용하여 `DFS`를 구현하여 문제를 풀었다.

출발노드부터 시작하여 인접한 노드를 탐색하면서, 도착노드를 방문했다면 성공, 전부 탐색했는데 못 방문했다면 실패

`DFS`에서 방문기록을 저장하는 리스트를 생성하는 것이 중요하다.

## 1219 길찾기

노드를 간선으로 연결한 그래프의 정보를 준다. 출발노드에서 도착노드에 도달할 수 있는지 구하는 문제

4871 그래프검사 문제와 똑같다.

## 같은 숫자는 싫어

입력 배열 중 같은 숫자가 나오면 하나는 삭제하고 출력하는 문제

스택을 사용하여 풀었다.

## 차르봄바

2차원 리스트로 이루어진 마을에서 P크기의 폭탄을 떨어뜨려 없앨 수 있는 최대의 바이러스 수를 구하는 문제

델타 탐색을 이용하여 구하였다.

결과값을 초기화 하는 부분의 위치를 신경써야한다.

`*`를 적절히 사용해보자

## 4874 Forth

후위계산식의 결과값을 구하는 문제

스택을 사용하였다.

사칙연산을 구현하는 부분이 중요하다.

`/`는 분모로 `0`을 사용할 수 없다.

정수를 `/`연산하면 실수가 나온다.

## 1221 계산식1

입력받은 계산식을 후위표현식으로 바꾼뒤 결과값을 출력하는 문제

스택을 사용하였다.

연산자 우선순위를 정해 스택에 넣는 순서를 정해주었다.

그 후 후위표현식을 `Forth`문제와 같은 방법으로 계산해주었다

## 4875 미로

미로가 주어질 때, 출발점에서 도착점까지 도달할 수 있는지를 구하는 문제

DFS의 델타탐색을 사용하여 문제를 풀었다.

방문 가능한 지점에 대한 조건에 대해 고려할게 많다.

## 4881 배열 최소합

NxN 배열의 숫자에서 N개의 숫자를 골라 합의 최소를 구하는 문제

순열을 사용하여 문제를 풀었다

순열의 이해가 좀 더 필요함

## 1223 계산기2

주어진 계산식을 후위표현식으로 바꾼뒤 계산 결과를 구하는 문제

스택을 사용하여 후위표현식으로 바꿔주는 함수를 만들었다

바꿔준 후위표현식을 스택을 사용하여 계산해주었다.

## 사각형 그리기

주어진 게임판의 규칙을 따라 사각형을 그릴 때 최대 면적으로 그릴 수 있는 사각형의 개수를 구하는 문제

게임판의 좌표를 모두 순회하면서 그릴 수 있는 사각형의 면적을 구했다.

사각형을 그리는 함수를 만들 때 우측 하단에 좌표를 비교해줘야하기 때문에 범위를 잘 지정해줘야 한다.


## 1225 암호생성기
일정한 규칙으로 변경되는 암호문을 생성하는 문제

8개의 숫자를 5번을 바꾸면 1사이클이 된다.

1사이클 동안 암호문을 변경하는 함수를 만들었다.

한 숫자가 0이 될때 까지 반복하여 암호문을 만들었다.

일정한 규칙을 찾아 사이클을 도는 횟수를 줄였다.


## 1860 진기의 최고급 붕어빵
M초동안 K개의 붕어빵을 만드는데 N명의 손님이 기다리지 않고 붕어빵을 받을 수 있을 지 구하는 문제

손님의 대기시간을 정렬했다.

반복하면서 K개의 붕어빵을 만들때마다 대기시간과 비교하면서 가능여부를 보았다.

`for-else문`을 사용하였다.

`return`을 사용하기위해 함수로 만들었다.


## 5099 피자굽기
피자를 구울 때 마지막에 꺼내는 피자의 번호를 구하는 문제

피자의 치즈양이 입력될 때 순서와 치즈양을 리스트로 가지는 리스트를 다시 만들어줌

화덕은 원형으로 이루어짐으로 `deque`을 사용해서 구현해주었다.

하나씩 피자를 꺼내며 다 구워졌으면 다음 피자를 넣어서 구워주었다

마지막에 나온 피자의 인덱스 번호를 출력해준다.


## 5907 회전
N개의 숫자열을 M번 회전시켰을 때 첫번 째 숫자를 출력하는 문제

나머지 연산으로 구함

`queue`로 구할수도 있다


## 1970 쉬운 거스름돈
거스름돈이 주어졌을 때 화폐의 최소 개수를 구하는 문제

화폐들의 개수를 딕셔너리로 만들어 순회하면 개수를 구해주었다.